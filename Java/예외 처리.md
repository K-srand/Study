참고: 자바의 경우 GC가 있기 때문에 JVM 메모리에 있는 인스턴스는 자동으로 해제할 수 있음.
하지만 외부 연결과 같은 자바 외부의 자원은 자동으로 해제가 되지 않음.
따라서 외부 자원을 사용한 후에는 연결을 해제해서 외부 자원을 반드시 반납해야함.

![image](https://sj-obsidian-bucket.s3.ap-northeast-2.amazonaws.com/053b23dee725d013b97b25dd87e50b15.png)
출처 : 김영한의 실전 자바 - 중급

**체크 예외 vs 언체크 예외(런타임 예외)**
- 체크 예외 : 개발자가 명시적 처리, 그렇지 않으면 컴파일 오류 발생
- 언체크 예외 : 개발자가 발생한 예외를 명시적으로 처리하지 않아도 됨.

**주의**
상속 관계에서 부모 타입은 자식을 담을 수 있음. 이 개념이 예외 처리에도 적용.
상위 예외를 catch로 잡으면 그 하위 예외까지 함께 잡음.
따라서 애플리케이션 로직에서는 Throwable 예외를 잡으면 안되는데, 잡으면 안되는 Error 예외도 함께 잡을 수 있음. 애플리케이션 로직은 이런 이유로 Exception부터 필요한 예외로 생각하고 잡으면 됨.


### 체크 예외
catch로 잡아서 처리하거나 throw로 던져야 함.
`throw` : 새로운 예외 발생시킬 수 있음. 예외도 객체이기  대문에 객체를 먼저 new로 생성하고 예외를 발생시킴.
`throws`  발생시킨 예외를 메서드 밖으로 던질 때 사용하는 키워드

장점 : 개발자가 실수로 예외를 누락하지 않도록 컴파일러를 통해 문제를 잡아주는 안정 장치.
개발자는 어떤 체크 예외가 발생하는지 쉽게 파악.
단점 : 실제로 개발자가 모든 체크 예외를 반드시 잡거나 던지도록 처리해야 하기 때문에 너무 번거로움. 크게 신경쓰고 싶지 않은 예외까지 모두 챙겨야함.

### 언체크 예외
체크 예외와 차이점은 예외를 던지는 throws를 선언하지 않고, 생략 가능.
생략한 경우 자동으로 예외 던짐.

언체크 예외도 throws 예외를 선언해도 됨.
주로 생략하나 중요한 예외의 경우 선언해두면 해당 코드를 호출하는 개발자가 이런 예외가 발생한다는 점을 IDE를 통해 편리하게 인지할 수 있음.

장점 : 신경쓰고 싶지 않은 언체크 예외를 무시할 수 있음. 체크 예외의 경우 처리할 수 없는 예외를 밖으로 던지려면 항상 throws 예외를 선언해야하지만, 언체크 예외는 생략 가능.
단점 : 언체크 예외는 개발자가 실수로 예외를 누락할 수 있음. 반면, 체크 예외는 컴파일러를 통해 예외 누락 잡아줌.

### 예외 계층
예외가 발생했을 때 catch를 순서대로 실행하므로, 더 디테일한 자식을 먼저 잡아야 함.


### try-with-resources
자바 7부터 try에서 외부 자원을 사용하고, try가 끝나면 외부 자원을 반납하는 패턴이 반복되면서 try-with-resources라는 편의 기능 도입.
finally가 없어도 됨.


